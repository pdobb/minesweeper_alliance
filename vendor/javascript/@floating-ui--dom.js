// @floating-ui/dom@1.7.0 downloaded from https://ga.jspm.io/npm:@floating-ui/dom@1.7.0/dist/floating-ui.dom.mjs

import{rectToClientRect as t,detectOverflow as e,offset as n,autoPlacement as o,shift as i,flip as s,size as c,hide as r,arrow as l,inline as f,limitShift as u,computePosition as h}from"@floating-ui/core";import{round as a,createCoords as d,max as g,min as p,floor as x}from"@floating-ui/utils";import{getComputedStyle as y,isHTMLElement as m,isElement as w,getWindow as v,isWebKit as b,getFrameElement as R,getNodeScroll as L,getDocumentElement as T,isTopLayer as F,getNodeName as E,isOverflowElement as O,getParentNode as W,isLastTraversableNode as C,getOverflowAncestors as H,isContainingBlock as z,isTableElement as A,getContainingBlock as B}from"@floating-ui/utils/dom";export{getOverflowAncestors}from"@floating-ui/utils/dom";function P(t){const e=y(t);let n=parseFloat(e.width)||0;let o=parseFloat(e.height)||0;const i=m(t);const s=i?t.offsetWidth:n;const c=i?t.offsetHeight:o;const r=a(n)!==s||a(o)!==c;if(r){n=s;o=c}return{width:n,height:o,$:r}}function D(t){return w(t)?t:t.contextElement}function V(t){const e=D(t);if(!m(e))return d(1);const n=e.getBoundingClientRect();const{width:o,height:i,$:s}=P(e);let c=(s?a(n.width):n.width)/o;let r=(s?a(n.height):n.height)/i;c&&Number.isFinite(c)||(c=1);r&&Number.isFinite(r)||(r=1);return{x:c,y:r}}const S=d(0);function I(t){const e=v(t);return b()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:S}function q(t,e,n){e===void 0&&(e=false);return!(!n||e&&n!==v(t))&&e}function M(e,n,o,i){n===void 0&&(n=false);o===void 0&&(o=false);const s=e.getBoundingClientRect();const c=D(e);let r=d(1);n&&(i?w(i)&&(r=V(i)):r=V(e));const l=q(c,o,i)?I(c):d(0);let f=(s.left+l.x)/r.x;let u=(s.top+l.y)/r.y;let h=s.width/r.x;let a=s.height/r.y;if(c){const t=v(c);const e=i&&w(i)?v(i):i;let n=t;let o=R(n);while(o&&i&&e!==n){const t=V(o);const e=o.getBoundingClientRect();const i=y(o);const s=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x;const c=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;f*=t.x;u*=t.y;h*=t.x;a*=t.y;f+=s;u+=c;n=v(o);o=R(n)}}return t({width:h,height:a,x:f,y:u})}function N(t,e){const n=L(t).scrollLeft;return e?e.left+n:M(T(t)).left+n}function $(t,e,n){n===void 0&&(n=false);const o=t.getBoundingClientRect();const i=o.left+e.scrollLeft-(n?0:N(t,o));const s=o.top+e.scrollTop;return{x:i,y:s}}function _(t){let{elements:e,rect:n,offsetParent:o,strategy:i}=t;const s=i==="fixed";const c=T(o);const r=!!e&&F(e.floating);if(o===c||r&&s)return n;let l={scrollLeft:0,scrollTop:0};let f=d(1);const u=d(0);const h=m(o);if(h||!h&&!s){(E(o)!=="body"||O(c))&&(l=L(o));if(m(o)){const t=M(o);f=V(o);u.x=t.x+o.clientLeft;u.y=t.y+o.clientTop}}const a=!c||h||s?d(0):$(c,l,true);return{width:n.width*f.x,height:n.height*f.y,x:n.x*f.x-l.scrollLeft*f.x+u.x+a.x,y:n.y*f.y-l.scrollTop*f.y+u.y+a.y}}function j(t){return Array.from(t.getClientRects())}function k(t){const e=T(t);const n=L(t);const o=t.ownerDocument.body;const i=g(e.scrollWidth,e.clientWidth,o.scrollWidth,o.clientWidth);const s=g(e.scrollHeight,e.clientHeight,o.scrollHeight,o.clientHeight);let c=-n.scrollLeft+N(t);const r=-n.scrollTop;y(o).direction==="rtl"&&(c+=g(e.clientWidth,o.clientWidth)-i);return{width:i,height:s,x:c,y:r}}function G(t,e){const n=v(t);const o=T(t);const i=n.visualViewport;let s=o.clientWidth;let c=o.clientHeight;let r=0;let l=0;if(i){s=i.width;c=i.height;const t=b();if(!t||t&&e==="fixed"){r=i.offsetLeft;l=i.offsetTop}}return{width:s,height:c,x:r,y:l}}function J(t,e){const n=M(t,true,e==="fixed");const o=n.top+t.clientTop;const i=n.left+t.clientLeft;const s=m(t)?V(t):d(1);const c=t.clientWidth*s.x;const r=t.clientHeight*s.y;const l=i*s.x;const f=o*s.y;return{width:c,height:r,x:l,y:f}}function K(e,n,o){let i;if(n==="viewport")i=G(e,o);else if(n==="document")i=k(T(e));else if(w(n))i=J(n,o);else{const t=I(e);i={x:n.x-t.x,y:n.y-t.y,width:n.width,height:n.height}}return t(i)}function Q(t,e){const n=W(t);return!(n===e||!w(n)||C(n))&&(y(n).position==="fixed"||Q(n,e))}function U(t,e){const n=e.get(t);if(n)return n;let o=H(t,[],false).filter((t=>w(t)&&E(t)!=="body"));let i=null;const s=y(t).position==="fixed";let c=s?W(t):t;while(w(c)&&!C(c)){const e=y(c);const n=z(c);n||e.position!=="fixed"||(i=null);const r=s?!n&&!i:!n&&e.position==="static"&&!!i&&["absolute","fixed"].includes(i.position)||O(c)&&!n&&Q(t,c);r?o=o.filter((t=>t!==c)):i=e;c=W(c)}e.set(t,o);return o}function X(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const s=n==="clippingAncestors"?F(e)?[]:U(e,this._c):[].concat(n);const c=[...s,o];const r=c[0];const l=c.reduce(((t,n)=>{const o=K(e,n,i);t.top=g(o.top,t.top);t.right=p(o.right,t.right);t.bottom=p(o.bottom,t.bottom);t.left=g(o.left,t.left);return t}),K(e,r,i));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function Y(t){const{width:e,height:n}=P(t);return{width:e,height:n}}function Z(t,e,n){const o=m(e);const i=T(e);const s=n==="fixed";const c=M(t,true,s,e);let r={scrollLeft:0,scrollTop:0};const l=d(0);function f(){l.x=N(i)}if(o||!o&&!s){(E(e)!=="body"||O(i))&&(r=L(e));if(o){const t=M(e,true,s,e);l.x=t.x+e.clientLeft;l.y=t.y+e.clientTop}else i&&f()}s&&!o&&i&&f();const u=!i||o||s?d(0):$(i,r);const h=c.left+r.scrollLeft-l.x-u.x;const a=c.top+r.scrollTop-l.y-u.y;return{x:h,y:a,width:c.width,height:c.height}}function tt(t){return y(t).position==="static"}function et(t,e){if(!m(t)||y(t).position==="fixed")return null;if(e)return e(t);let n=t.offsetParent;T(t)===n&&(n=n.ownerDocument.body);return n}function nt(t,e){const n=v(t);if(F(t))return n;if(!m(t)){let e=W(t);while(e&&!C(e)){if(w(e)&&!tt(e))return e;e=W(e)}return n}let o=et(t,e);while(o&&A(o)&&tt(o))o=et(o,e);return o&&C(o)&&tt(o)&&!z(o)?n:o||B(t)||n}const ot=async function(t){const e=this.getOffsetParent||nt;const n=this.getDimensions;const o=await n(t.floating);return{reference:Z(t.reference,await e(t.floating),t.strategy),floating:{x:0,y:0,width:o.width,height:o.height}}};function it(t){return y(t).direction==="rtl"}const st={convertOffsetParentRelativeRectToViewportRelativeRect:_,getDocumentElement:T,getClippingRect:X,getOffsetParent:nt,getElementRects:ot,getClientRects:j,getDimensions:Y,getScale:V,isElement:w,isRTL:it};function ct(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}function rt(t,e){let n=null;let o;const i=T(t);function s(){var t;clearTimeout(o);(t=n)==null||t.disconnect();n=null}function c(r,l){r===void 0&&(r=false);l===void 0&&(l=1);s();const f=t.getBoundingClientRect();const{left:u,top:h,width:a,height:d}=f;r||e();if(!a||!d)return;const y=x(h);const m=x(i.clientWidth-(u+a));const w=x(i.clientHeight-(h+d));const v=x(u);const b=-y+"px "+-m+"px "+-w+"px "+-v+"px";const R={rootMargin:b,threshold:g(0,p(1,l))||1};let L=true;function T(e){const n=e[0].intersectionRatio;if(n!==l){if(!L)return c();n?c(false,n):o=setTimeout((()=>{c(false,1e-7)}),1e3)}n!==1||ct(f,t.getBoundingClientRect())||c();L=false}try{n=new IntersectionObserver(T,{...R,root:i.ownerDocument})}catch(t){n=new IntersectionObserver(T,R)}n.observe(t)}c(true);return s}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */function lt(t,e,n,o){o===void 0&&(o={});const{ancestorScroll:i=true,ancestorResize:s=true,elementResize:c=typeof ResizeObserver==="function",layoutShift:r=typeof IntersectionObserver==="function",animationFrame:l=false}=o;const f=D(t);const u=i||s?[...f?H(f):[],...H(e)]:[];u.forEach((t=>{i&&t.addEventListener("scroll",n,{passive:true});s&&t.addEventListener("resize",n)}));const h=f&&r?rt(f,n):null;let a=-1;let d=null;if(c){d=new ResizeObserver((t=>{let[o]=t;if(o&&o.target===f&&d){d.unobserve(e);cancelAnimationFrame(a);a=requestAnimationFrame((()=>{var t;(t=d)==null||t.observe(e)}))}n()}));f&&!l&&d.observe(f);d.observe(e)}let g;let p=l?M(t):null;l&&x();function x(){const e=M(t);p&&!ct(p,e)&&n();p=e;g=requestAnimationFrame(x)}n();return()=>{var t;u.forEach((t=>{i&&t.removeEventListener("scroll",n);s&&t.removeEventListener("resize",n)}));h==null||h();(t=d)==null||t.disconnect();d=null;l&&cancelAnimationFrame(g)}}const ft=e;const ut=n;const ht=o;const at=i;const dt=s;const gt=c;const pt=r;const xt=l;const yt=f;const mt=u;const wt=(t,e,n)=>{const o=new Map;const i={platform:st,...n};const s={...i.platform,_c:o};return h(t,e,{...i,platform:s})};export{xt as arrow,ht as autoPlacement,lt as autoUpdate,wt as computePosition,ft as detectOverflow,dt as flip,pt as hide,yt as inline,mt as limitShift,ut as offset,st as platform,at as shift,gt as size};

